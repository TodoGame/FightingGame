package websocket

import com.somegame.BaseKoinTest
import com.somegame.user.repository.MockUserRepositoryFactory
import com.somegame.websocket.WebSocketTicketManager
import kotlinx.coroutines.runBlocking
import org.junit.jupiter.api.Assertions.assertEquals
import org.junit.jupiter.api.Assertions.assertThrows
import org.junit.jupiter.api.BeforeEach
import org.junit.jupiter.api.Test

internal class WebSocketTicketManagerTest : BaseKoinTest() {
    private lateinit var ticketManager: WebSocketTicketManager
    private lateinit var ticketManager2: WebSocketTicketManager
    private lateinit var instantExpireTicketManager: WebSocketTicketManager
    private lateinit var singleTicketManager: WebSocketTicketManager

    @BeforeEach
    fun init() {
        ticketManager = WebSocketTicketManager("wsname")
        ticketManager2 = WebSocketTicketManager("otherwsname")
        instantExpireTicketManager = WebSocketTicketManager("instant expire", 0)
        singleTicketManager = WebSocketTicketManager("single")
    }

    @Test
    fun `should authorize tickets that are generated by this ticket manager`() = runBlocking {
        val userPrincipal = MockUserRepositoryFactory.user1.getPrincipal()
        val ticket = ticketManager.makeTicket(MockUserRepositoryFactory.user1.getPrincipal())
        val user = ticketManager.authorize(ticket)
        assertEquals(userPrincipal.username, user.username)
    }

    @Test
    fun `should not authorize the same ticket twice`(): Unit = runBlocking {
        val ticket = ticketManager.makeTicket(MockUserRepositoryFactory.user1.getPrincipal())
        ticketManager.authorize(ticket)
        assertThrows(WebSocketTicketManager.InvalidTicketException::class.java) {
            runBlocking {
                ticketManager.authorize(ticket)
            }
        }
    }

    @Test
    fun `should not authorize random tickets with incorrect name`(): Unit = runBlocking {
        val expiresAt = System.currentTimeMillis() + 60 * 1000
        val ticket = WebSocketTicket("incorrent name", MockUserRepositoryFactory.user1.username, expiresAt, "some code")
        assertThrows(WebSocketTicketManager.InvalidTicketException::class.java) {
            runBlocking {
                ticketManager.authorize(ticket)
            }
        }
    }

    @Test
    fun `should not authorize tickets with correct name but with fake username`(): Unit = runBlocking {
        val expiresAt = System.currentTimeMillis() + 60 * 1000
        val ticket = WebSocketTicket("wsname", MockUserRepositoryFactory.fakeUser.username, expiresAt, "some code")
        assertThrows(WebSocketTicketManager.InvalidTicketException::class.java) {
            runBlocking {
                ticketManager.authorize(ticket)
            }
        }
    }

    @Test
    fun `should not authorize registered tickets but with changed code`(): Unit = runBlocking {
        val ticket = ticketManager.makeTicket(MockUserRepositoryFactory.user1.getPrincipal())
        val fakeTicket =
            WebSocketTicket(ticket.webSocketName, ticket.username, ticket.expiresAt, ticket.code + " but fake")
        assertThrows(WebSocketTicketManager.InvalidTicketException::class.java) {
            runBlocking {
                ticketManager.authorize(fakeTicket)
            }
        }
    }

    @Test
    fun `should not authorize tickets registered by another ticket manager`(): Unit = runBlocking {
        val ticket = ticketManager2.makeTicket(MockUserRepositoryFactory.user1.getPrincipal())
        assertThrows(WebSocketTicketManager.InvalidTicketException::class.java) {
            runBlocking {
                ticketManager.authorize(ticket)
            }
        }
    }

    @Test
    fun `should not authorize registered tickets but with changed username`(): Unit = runBlocking {
        val ticket = ticketManager.makeTicket(MockUserRepositoryFactory.user1.getPrincipal())
        val fakeTicket =
            WebSocketTicket(ticket.webSocketName, MockUserRepositoryFactory.user2.username, ticket.expiresAt, ticket.code)
        assertThrows(WebSocketTicketManager.InvalidTicketException::class.java) {
            runBlocking {
                ticketManager.authorize(fakeTicket)
            }
        }
    }

    @Test
    fun `should not authorize expired tickets`(): Unit = runBlocking {
        val expiredTicket = instantExpireTicketManager.makeTicket(MockUserRepositoryFactory.user1.getPrincipal())
        assertThrows(WebSocketTicketManager.InvalidTicketException::class.java) {
            runBlocking {
                instantExpireTicketManager.authorize(expiredTicket)
            }
        }
    }
}
