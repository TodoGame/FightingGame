package websocket

import com.somegame.BaseKoinTest
import com.somegame.user.repository.MockUserRepository
import com.somegame.websocket.WebSocketTicketManager
import junit.framework.Assert.assertEquals
import kotlinx.coroutines.launch
import kotlinx.coroutines.runBlocking
import org.junit.jupiter.api.Assertions.assertThrows
import org.junit.jupiter.api.BeforeEach
import org.junit.jupiter.api.Test
import java.util.concurrent.atomic.AtomicInteger

internal class WebSocketTicketManagerTest : BaseKoinTest() {
    private lateinit var ticketManager: WebSocketTicketManager
    private lateinit var ticketManager2: WebSocketTicketManager
    private lateinit var instantExpireTicketManager: WebSocketTicketManager
    private lateinit var singleTicketManager: WebSocketTicketManager

    @BeforeEach
    fun init() {
        ticketManager = WebSocketTicketManager("wsname", -1)
        ticketManager2 = WebSocketTicketManager("otherwsname", -1)
        instantExpireTicketManager = WebSocketTicketManager("instant expire", -1, 0)
        singleTicketManager = WebSocketTicketManager("single", 1)
    }

    @Test
    fun `should authorize tickets that are generated by this ticket manager`() {
        val userPrincipal = MockUserRepository.user1.getPrincipal()
        val ticket = ticketManager.makeTicket(MockUserRepository.user1.getPrincipal())
        val user = ticketManager.authorize(ticket)
        assertEquals(userPrincipal.username, user.username)
    }

    @Test
    fun `should not authorize the same ticket twice`() {
        val ticket = ticketManager.makeTicket(MockUserRepository.user1.getPrincipal())
        ticketManager.authorize(ticket)
        assertThrows(WebSocketTicketManager.InvalidTicketException::class.java) {
            ticketManager.authorize(ticket)
        }
    }

    @Test
    fun `should not authorize random tickets with incorrect name`() {
        val expiresAt = System.currentTimeMillis() + 60 * 1000
        val ticket = WebSocketTicket("incorrent name", MockUserRepository.user1.username, expiresAt, "some code")
        assertThrows(WebSocketTicketManager.InvalidTicketException::class.java) {
            ticketManager.authorize(ticket)
        }
    }

    @Test
    fun `should not authorize tickets with correct name but with fake username`() {
        val expiresAt = System.currentTimeMillis() + 60 * 1000
        val ticket = WebSocketTicket("wsname", MockUserRepository.fakeUser.username, expiresAt, "some code")
        assertThrows(WebSocketTicketManager.InvalidTicketException::class.java) {
            ticketManager.authorize(ticket)
        }
    }

    @Test
    fun `should not authorize registered tickets but with changed code`() {
        val ticket = ticketManager.makeTicket(MockUserRepository.user1.getPrincipal())
        val fakeTicket =
            WebSocketTicket(ticket.webSocketName, ticket.username, ticket.expiresAt, ticket.code + " but fake")
        assertThrows(WebSocketTicketManager.InvalidTicketException::class.java) {
            ticketManager.authorize(fakeTicket)
        }
    }

    @Test
    fun `should not authorize tickets registered by another ticket manager`() {
        val ticket = ticketManager2.makeTicket(MockUserRepository.user1.getPrincipal())
        assertThrows(WebSocketTicketManager.InvalidTicketException::class.java) {
            ticketManager.authorize(ticket)
        }
    }

    @Test
    fun `should not authorize registered tickets but with changed username`() {
        val ticket = ticketManager.makeTicket(MockUserRepository.user1.getPrincipal())
        val fakeTicket = WebSocketTicket(ticket.webSocketName, MockUserRepository.user2.username, ticket.expiresAt, ticket.code)
        assertThrows(WebSocketTicketManager.InvalidTicketException::class.java) {
            ticketManager.authorize(fakeTicket)
        }
    }

    @Test
    fun `should not authorize expired tickets`() {
        val expiredTicket = instantExpireTicketManager.makeTicket(MockUserRepository.user1.getPrincipal())
        assertThrows(WebSocketTicketManager.InvalidTicketException::class.java) {
            instantExpireTicketManager.authorize(expiredTicket)
        }
    }

    @Test
    fun `single ticket manager should only give one ticket for 100 concurrent users`() {
        val ticketsCount = AtomicInteger()
        runBlocking {
            for (i in 0 until 100) {
                launch {
                    try {
                        singleTicketManager.makeTicket(MockUserRepository.user1.getPrincipal())
                        ticketsCount.incrementAndGet()
                    } catch (e: WebSocketTicketManager.MaxNumberOfTicketsReachedException) {
                        // do nothing
                    }
                }
            }
        }
        assertEquals(1, ticketsCount.get())
    }

    @Test
    fun `single ticket manager should only give one ticket for 1000 concurrent users`() {
        val ticketsCount = AtomicInteger()
        runBlocking {
            for (i in 0 until 1000) {
                launch {
                    try {
                        singleTicketManager.makeTicket(MockUserRepository.user1.getPrincipal())
                        ticketsCount.incrementAndGet()
                    } catch (e: WebSocketTicketManager.MaxNumberOfTicketsReachedException) {
                        // do nothing
                    }
                }
            }
        }
        assertEquals(1, ticketsCount.get())
    }
}
